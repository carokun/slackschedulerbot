# slackschedulerbot
Overview

what? a language-aware intellegent Slack bot for scheduling reminders and meetings with other Slack users in Google Calendar
who? me and three other programmers from my summer coding bootcamp
how? our application was built on top of three APIs including the Slack API,  the Google Calendar API, and API.AI's language processing API.



This past week me and my team of three other programmers built a language-aware Slack bot for scheduling reminders and meetings with other Slack users. The application combined multiple APIs including the Slack API,  the Google Calendar API, and API.AI's language processing API. Some highlights and challenges of the project included handling asynchronous code, integration of multiple APIs, working on a team, and deploying to production. 

Working in a Team

Our first challenge when setting up the structure of our application was delegating work in an efficienct manner.  We managed the organization of the project through a shared trello board where we separated each milestone into several smaller steps that we could then assign to different team members each day. Each of us had a production branch on our gitrepo where we would do our days work. When a team member had completed a task and tested their code, that member would create a pull request and following a code review they would merge their branch with master. Getting a handle of merge conflicts was definitely a challenge towards the beginning so on day three we refactored a lot of our files, moving helper functions into separate files so we weren't working in the same files as another team member. This also made a code a lot more readable.

APIs and Asynchronous Code

Our second challenge was integrating logic from asynchronous calls to the three outside APIs and MongoDB. 
Understanding the different APIs took a lot of the first day because the SDKs for both the Slack and Google APIs were autogenerated and not very readable. I did a lot of the work with API.AI at the beginning which comprised the machine learning side of the project. This included training the bot to handle multiple intents such as requests for scheduling meetings and setting reminders. Later on I became incharge of the Slack interactions which meant I connected the slack user's interactions with all the separate calls to different exteneral sources, analyzing their messages with API.AI and handling them according to the response I received from API.AI.

Managing State

We used MongoDB as the place to store users' slack and google information as well as the pending state of any processing requests. We also learned how to access pending conversion state from API.AI which stores the data of any currently processing intents. The database held three models including users, reminders, and meetings.  The pending state stored in MongoDB was attached to a user and held information about confirmations, meeting conflicts, and the current stage of a user's requests.

Deploying to production

The final step was deploying our bot to production. We hosted our application on heroku and in the end we were running our Slack bot, an express server, and two scheduled bots using Heroku Scheduler. The scheduled bots interacted with our stored state in MongoDB and grabbed user information to send timed messages to the Slack users. The first scheduled bot was in charge of sending event reminders the day before an event and the second scheduled bot was in charge of updating an event if a unauthorized user invited to a meeting later authorized themself. 

Wrap Up

I definitely learned a lot about code organization and working in a team from this project. It taught me the importance of segmenting, testing, and commenting code especially when collaboriting on a larger scale project. Refactoring the structure of our code mid-way through was extremely helpful and allowed our hard work to result in a functional and comprehensive application. 

